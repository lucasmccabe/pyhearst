import re
import string
import nltk
from nltk.tokenize.treebank import TreebankWordDetokenizer
from typing import List
import inflect

class PyHearst:
    '''
    PyHearst class. TODO: more documentation here

    '''

    def __init__(self):
        '''
        Constructor for the PyHearst class. TODO: more documentation here

        '''

        self.patterns = [('(such NP_[\w.]* as NP_[\w.]*(,? (and | or )?NP_[\w.]*)*)', 0),
                           ('(NP_[\w.]*,? such as NP_[\w.]*(,? (and | or )?NP_[\w.]*)*)', 0),
                           ('(NP_[\w.]*(, NP_[\w.]*)*,? (and|or)? other NP_[\w.]*)', 1),
                           ('(NP_[\w.]*,? including NP_[\w.]*(,? (and | or )?NP_[\w.]*)*)', 0),
                           ('(NP_[\w.]*,? especially NP_[\w.]*(,? (and | or )?NP_[\w.]*)*)', 0)
                          ]

        self.tests = ['works by such individuals as Marti A. Hearst, P. J. Proudhon, and Esther Duflo and also foods such as pancakes, waffles, and eggs',
                         'bruises, wounds, bones, or other injuries',
                         'sports such as basketball and baseball',
                         'beans, such as pinto and kidney',
                         'temples, treasuries, and other buildings',
                         'countries, including Canada and England',
                         'countries, especially France, England, and Spain'
                        ]

    def annotate_sentence(self, sent: str) -> str:
        '''
        Returns a sentence with NPs tagged inline.

        Example Usage:
            >>> text = 'works by such authors as J. K. Rowling, Goldsmith, and Shakespeare.'
            >>> annotate_sentence(text)
            'NP_works by such NP_authors as NP_J._K._Rowling, NP_Goldsmith, and NP_Shakespeare.'
        '''
        tagged_sent = nltk.pos_tag(nltk.word_tokenize(sent))

        NPs = set([tup[0] for tup in tagged_sent if tup[1].startswith('NN')])
        for NP in NPs:
            sent = sent.replace(NP, 'NP_'+NP) #adds NP tag

        return self.merge_consecutive_NPs(sent)


    def merge_consecutive_NPs(self, annotated_sentence: str) -> str:
        '''
        Merges consecutive tagged NPs in an annotated sentence.

        Args:
            annotated_sentence: NP_-annotated sentence as generated by annotate_sentence()
        Returns:
            annotated_sentnece with consecutive NPs merged and initialed NPs handled

        Example Usage:
            >>> annotated_sentence = 'NP_works by such NP_authors as NP_J. NP_K. NP_Rowling, NP_Goldsmith, and NP_Shakespeare.'
            >>> merge_consecutive_NPs(annotated_sentence)
            'NP_works by such NP_authors as NP_J._K._Rowling, NP_Goldsmith, and NP_Shakespeare.'
        '''

        toks = nltk.word_tokenize(annotated_sentence)

        #merge initialed NPs to handle instances like J. K. Rowling
        for i in range(len(toks)-1, 0, -1):
            if toks[i] == '.' and i!= len(toks)-1:
                toks[i-1:i+1] = [toks[i-1] + toks[i]]

        NP_indices = [i for i in range(len(toks)) if toks[i].startswith('NP_')] #inidices of all NP_-tagged tokens

        #if two consecutive tokens are tagged NP_, then merge them into one token
        for i in range(len(NP_indices)-1, 0, -1):
            if NP_indices[i]-1 == NP_indices[i-1]:
                toks[NP_indices[i-1]:NP_indices[i]+1] = [toks[NP_indices[i-1]] +'_' + toks[NP_indices[i]][3:]]

        #untokenize and return:
        return ''.join([' '+tok if not tok.startswith('\'') and
                        tok not in string.punctuation else
                        tok for tok in toks]).strip()
